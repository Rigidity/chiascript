"use strict";
exports.__esModule = true;
exports.parse = void 0;
var dissector_1 = require("dissector");
var types_1 = require("./types");
var $ = new dissector_1.Parser();
var statement = $.recursive();
var expression = $.recursive();
var type = $.recursive();
var identifierStart = $.or($.range('a', 'z'), $.range('A', 'Z'), '_');
var identifierChar = $.or(identifierStart, $.range('0', '9'));
var identifier = $.token(types_1.TokenKind.Identifier, $.lookahead(false, $.keyword($.or('def', 'puzzle', 'type', 'let', 'return', 'if', 'elif', 'else', 'then', 'do', 'or', 'and', 'is', 'as', 'in', 'not'))), $.combine(identifierStart, $.zero(identifierChar)));
$.boundary = identifierChar;
var hexDigit = $.or($.range('0', '9'), $.range('a', 'f'), $.range('A', 'F'));
var hexLiteral = $.token(types_1.TokenKind.HexLiteral, $.combine($.hide('0', $.or('x', 'X')), $.one(hexDigit)));
var decimalDigit = $.range('0', '9');
var integerLiteral = $.token(types_1.TokenKind.IntegerLiteral, $.combine($.one(decimalDigit)));
var octalDigit = $.range('0', '7');
var octalLiteral = $.token(types_1.TokenKind.OctalLiteral, $.combine($.hide('0', $.or('o', 'O')), $.one(octalDigit)));
var binaryDigit = $.or('0', '1');
var binaryLiteral = $.token(types_1.TokenKind.BinaryLiteral, $.combine($.hide('0', $.or('b', 'B')), $.one(binaryDigit)));
var hexEscape = $.token(types_1.TokenKind.HexEscape, $.hide('x'), $.repeat(2, hexDigit));
var unicodeEscape = $.token(types_1.TokenKind.UnicodeEscape, $.hide('u'), $.repeat(4, hexDigit));
var extendedEscape = $.token(types_1.TokenKind.ExtendedEscape, $.hide('u{'), $.between(2, 6, hexDigit), $.hide('}'));
var characterEscape = $.token(types_1.TokenKind.CharacterEscape, $.or('t', 'r', 'n'));
var stringEscape = $.or(hexEscape, unicodeEscape, extendedEscape, characterEscape, $.not($.or('\r', '\n')));
var stringLiteral = $.token(types_1.TokenKind.StringLiteral, $.push({ skip: [] }, $.or($.and('"', $.zero($.or($.and($.hide('\\'), stringEscape), $.not('\\', '"', '\r', '\n')), '"'), $.and("'", $.zero($.or($.and($.hide('\\'), stringEscape), $.not('\\', "'", '\r', '\n')), "'"))))));
var propertyAccess = $.token(types_1.TokenKind.PropertyAccess, $.hide('.'), identifier);
var optionalPropertyAccess = $.token(types_1.TokenKind.OptionalPropertyAccess, $.hide('?.'), identifier);
var valueAccess = $.token(types_1.TokenKind.ValueAccess, $.hide('['), expression, $.hide(']'));
var methodCall = $.token(types_1.TokenKind.MethodCall, $.hide('('), $.optional(expression, $.zero($.hide(','), expression), $.optional($.hide(','))), $.hide(')'));
var arrayLiteral = $.token(types_1.TokenKind.ArrayLiteral, $.hide('['), $.optional(expression, $.zero($.hide(','), expression), $.optional($.hide(','))), $.hide(']'));
var mapProperty = $.token(types_1.TokenKind.MapProperty, expression, $.hide(':'), expression);
var mapLiteral = $.token(types_1.TokenKind.MapLiteral, $.hide('{'), $.optional(mapProperty, $.zero($.hide(','), mapProperty), $.optional($.hide(','))), $.hide('}'));
var parameter = $.token(types_1.TokenKind.Parameter, identifier, $.optional($.hide(':'), type));
var parameterList = $.token(types_1.TokenKind.ParameterList, $.hide('('), $.optional(parameter, $.zero($.hide(','), parameter), $.optional($.hide(','))), $.hide(')'));
var functionExpression = $.token(types_1.TokenKind.FunctionExpression, $.hide($.keyword('def')), parameterList, $.optional($.hide(':'), type), $.hide('=>'), expression);
var puzzleExpression = $.token(types_1.TokenKind.PuzzleExpression, $.hide($.keyword('puzzle')), parameterList, $.optional($.hide(':'), type), $.hide('=>'), expression);
var elifExpression = $.token(types_1.TokenKind.ElifExpression, $.hide($.keyword('elif')), expression, $.hide($.keyword('do')), expression);
var elseExpression = $.token(types_1.TokenKind.ElseExpression, $.hide($.keyword('else')), expression);
var ifExpression = $.token(types_1.TokenKind.IfExpression, $.hide($.keyword('if')), expression, $.hide($.keyword('then')), expression, $.zero(elifExpression), $.optional(elseExpression));
var forExpression = $.token(types_1.TokenKind.ForExpression, $.hide($.keyword('for')), identifier, $.hide($.keyword('in')), expression, $.hide($.keyword('do')), expression);
var atomExpression = $.or(identifier, integerLiteral, stringLiteral, arrayLiteral, mapLiteral, hexLiteral, octalLiteral, binaryLiteral, functionExpression, puzzleExpression, ifExpression, forExpression, $.and($.hide('('), expression, $.hide(')')));
var suffixExpression = $.or($.token(types_1.TokenKind.SuffixExpression, atomExpression, $.one($.or(propertyAccess, optionalPropertyAccess, valueAccess, methodCall))), atomExpression);
var prefixExpression = $.or($.token(types_1.TokenKind.PrefixExpression, $.one($.or('+', '-', '~', $.keyword('not'))), suffixExpression), suffixExpression);
var rangeExpression = $.or($.token(types_1.TokenKind.RangeExpression, prefixExpression, $.hide($.or('...', '..')), prefixExpression, $.optional($.hide('::'), prefixExpression)), prefixExpression);
var factorExpression = $.or($.token(types_1.TokenKind.FactorExpression, rangeExpression, $.one($.or('*', '/', '%'), rangeExpression)), rangeExpression);
var termExpression = $.or($.token(types_1.TokenKind.TermExpression, factorExpression, $.one($.or('+', '-'), factorExpression)), factorExpression);
var shiftExpression = $.or($.token(types_1.TokenKind.ShiftExpression, termExpression, $.one($.or('<<<', '>>>', '<<', '>>'), termExpression)), termExpression);
var isNotExpression = $.token(types_1.TokenKind.IsNotExpression, $.hide($.keyword('is')), $.hide($.keyword('not')), type);
var isExpression = $.token(types_1.TokenKind.IsExpression, $.hide($.keyword('is')), type);
var asExpression = $.token(types_1.TokenKind.AsExpression, $.hide($.keyword('as')), type);
var inExpression = $.token(types_1.TokenKind.InExpression, $.hide($.keyword('in')), shiftExpression);
var notInExpression = $.token(types_1.TokenKind.NotInExpression, $.hide($.keyword('not')), $.hide($.keyword('in')), shiftExpression);
var checkExpression = $.or($.token(types_1.TokenKind.CheckExpression, shiftExpression, $.zero($.or(isNotExpression, isExpression, asExpression, notInExpression, inExpression))), shiftExpression);
var equalityExpression = $.or($.token(types_1.TokenKind.EqualityExpression, checkExpression, $.one($.or('==', '!=', '<=', '>=', '<', '>'), checkExpression)), checkExpression);
var bitwiseAndExpression = $.or($.token(types_1.TokenKind.BitwiseAndExpression, equalityExpression, $.one($.hide('&'), equalityExpression)), equalityExpression);
var bitwiseXorExpression = $.or($.token(types_1.TokenKind.BitwiseXorExpression, bitwiseAndExpression, $.one($.hide('^'), bitwiseAndExpression)), bitwiseAndExpression);
var bitwiseOrExpression = $.or($.token(types_1.TokenKind.BitwiseOrExpression, bitwiseXorExpression, $.one($.hide('|'), bitwiseXorExpression)), bitwiseXorExpression);
var logicalAndExpression = $.or($.token(types_1.TokenKind.LogicalAndExpression, bitwiseOrExpression, $.one($.hide($.keyword('and')), bitwiseOrExpression)), bitwiseOrExpression);
var logicalOrExpression = $.or($.token(types_1.TokenKind.LogicalOrExpression, logicalAndExpression, $.one($.hide($.keyword('or')), logicalAndExpression)), logicalAndExpression);
var referenceExpression = $.or($.token(types_1.TokenKind.ReferenceExpression, identifier, $.zero($.or(propertyAccess, valueAccess))), identifier);
expression.rule = $.or($.token(types_1.TokenKind.AssignmentExpression, referenceExpression, $.or('|=', '^=', '&=', '<<<=', '>>>=', '<<=', '>>=', '+=', '-=', '*=', '/=', '%=', '='), expression), logicalOrExpression);
var functionTypeParameters = $.token(types_1.TokenKind.FunctionTypeParameters, $.hide('('), $.optional(type, $.zero($.hide(','), type), $.optional($.hide(','))), $.hide(')'));
var tupleType = $.token(types_1.TokenKind.TupleType, $.hide('['), $.optional(type, $.zero($.hide(','), type), $.optional($.hide(','))), $.hide(']'));
var mapType = $.token(types_1.TokenKind.MapType, $.hide('{'), type, $.hide(':'), $.hide('}'));
var functionType = $.token(types_1.TokenKind.FunctionType, functionTypeParameters, $.hide('->'), type);
var atomType = $.or(tupleType, mapType, functionType, identifier, $.and($.hide('('), type, $.hide(')')));
var arrayType = $.token(types_1.TokenKind.ArrayType, $.hide('['), $.hide(']'));
var suffixType = $.or($.token(types_1.TokenKind.SuffixType, atomType, $.one(arrayType)), atomType);
type.rule = $.or($.token(types_1.TokenKind.UnionType, suffixType, $.one($.hide('|'), suffixType)), suffixType);
var block = $.token(types_1.TokenKind.Block, $.hide('{'), $.zero(statement), $.hide('}'));
var functionStatement = $.token(types_1.TokenKind.FunctionStatement, $.hide($.keyword('def')), identifier, parameterList, $.optional($.hide(':'), type), $.or($.and($.hide('=>'), statement), block));
var puzzleStatement = $.token(types_1.TokenKind.PuzzleStatement, $.hide($.keyword('puzzle')), identifier, parameterList, $.optional($.hide(':'), type), $.or($.and($.hide('=>'), statement), block));
var typeStatement = $.token(types_1.TokenKind.TypeStatement, $.hide($.keyword('type')), identifier, $.optional($.hide('='), type), $.hide(';'));
var letStatement = $.token(types_1.TokenKind.LetStatement, $.hide($.keyword('let')), identifier, $.optional($.hide(':'), type), $.optional($.hide('='), expression), $.hide(';'));
var returnStatement = $.token(types_1.TokenKind.ReturnStatement, $.hide($.keyword('return')), $.optional(expression), $.hide(';'));
var elifStatement = $.token(types_1.TokenKind.ElifStatement, $.hide($.keyword('elif')), expression, $.or($.and($.hide($.keyword('then')), statement), block));
var elseStatement = $.token(types_1.TokenKind.ElseStatement, $.hide($.keyword('else')), $.or(statement, block));
var ifStatement = $.token(types_1.TokenKind.IfStatement, $.hide($.keyword('if')), expression, $.or($.and($.hide($.keyword('then')), statement), block), $.zero(elifStatement), $.optional(elseStatement));
var forStatement = $.token(types_1.TokenKind.ForStatement, $.hide($.keyword('for')), identifier, $.hide($.keyword('in')), expression, $.or($.and($.hide($.keyword('do')), statement), block));
statement.rule = $.or(functionStatement, puzzleStatement, typeStatement, letStatement, returnStatement, ifStatement, forStatement, $.and($.optional(expression), $.hide(';')));
function parse(source) {
    return $.parse(source, types_1.TokenKind.Program, 'Mismatched input', $.zero(statement), $.end());
}
exports.parse = parse;
//# sourceMappingURL=parser.js.map